//! スライス（[*]T）は、長さ（usize）を持つ複数要素ポインタと考えることができる。
//! これらは []T の構文を使用する。
//! スライスは有効なバッファ長を保持するため、複数要素ポインタよりも安全に使用しやすく、便利である。
//! スライスは通常、通常のポインタの2倍のサイズであるため、「ファットポインタ」と呼ばれることもある。
//! Zig では、バッファを渡す最も一般的な方法がスライスである。
//!
//! 多要素ポインタとは異なり、forループはスライスに対して動作する。
//!
//! 配列からスライスを作成するには x[n..m] という構文を使用する。
//! これはスライシングと呼ばれる操作である。
//! これにより「スライス」が生成される。
//! スライスはポインタと長さを備えた配列へのビューである。
//! スライシングでは最初の要素 (n) は含むが、最後の要素 (m) は含まない。

const expect = @import("std").testing.expect;

// この例では、total 関数内で const スライスが使用されている。これはスライスのバッファに書き込みを行わないためである。

fn total(values: []const u8) usize {
    var sum: usize = 0;
    for (values) |v| sum += v; // スライスは長さを気にせず for で扱える
    return sum;
}

test "slices" {
    const array = [_]u8{ 1, 2, 3, 4, 5 };
    const slice = array[0..3]; // 配列をスライシングして一部の要素からスライスを作成
    try expect(total(slice) == 6);
}

// コンパイル時にこれらの n と m の値が両方とも既知の場合、スライシングは実際には配列へのポインタを生成する。
//これは問題ではない。なぜなら配列へのポインタ、すなわち *[N]T はスライス []T に強制変換されるためである。

test "slices 2" {
    const array = [_]u8{ 1, 2, 3, 4, 5 };
    const slice = array[0..3];
    try expect(@TypeOf(slice) == *const [3]u8);
}

// 末尾までスライスしたい場合にも、構文 x[n..] を使用できる。

test "slices 3" {
    var array = [_]u8{ 1, 2, 3, 4, 5 };
    const slice = array[0..];
    _ = slice;
}

// ポインタとスライスの比較表は https://zig.guide/master/language-basics/slices にある。
